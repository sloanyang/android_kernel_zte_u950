/*
 * ov8825.c - ov8825 sensor driver
 *
 * Copyright (c) 2011, NVIDIA, All Rights Reserved.
 *
 * Contributors:
 *      erik lilliebjerg <elilliebjerg@nvidia.com>
 *
 * Leverage OV5650.c
 *
 * This file is licensed under the terms of the GNU General Public License
 * version 2. This program is licensed "as is" without any warranty of any
 * kind, whether express or implied.
 */

#include <linux/delay.h>
#include <linux/fs.h>
#include <linux/i2c.h>
#include <linux/platform_device.h>
#include <linux/miscdevice.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <media/ov8825-i2c.h>
#include <media/ov8825.h>

#define OV8825_PRINT  0

struct ov8825_reg {
	u16 addr;
	u16 val;
};

struct ov8825_info {
	int mode;
	struct ov8825_platform_data *pdata;
};

static struct ov8825_info *info;

static u8 FuseID[5];
static u8 FuseIDReadOnce = 0;

#define OV8825_TABLE_WAIT_MS 0
#define OV8825_TABLE_END 1
#define OV8825_MAX_RETRIES 3
#define OV8825_OTP_WB_CAL_EN  1
#define OV8825_OTP_LENS_CAL_EN  2
#define OV8825_OTP_WB_LENS_CAL_UN  3

/* for cam calibration */
#include <linux/proc_fs.h>
#define CAM_CAL_PROC_FILE "driver/cam_cal"
static struct proc_dir_entry *cam_cal_proc_file;
u8 cam_cal_flag= 4;
 int ov8825_cam_clibratiion_flag(void)
{
    return cam_cal_flag;
}

static ssize_t cam_cal_proc_write(struct file *filp,
				    const char *buff, size_t len,
				    loff_t * off)
{
       u8 val;

	printk("cam_cal_proc_write\n");
	val=buff[0]-'0';
	cam_cal_flag = val;
	printk("cam_cal_proc_write cam_cal_flag=%d\n",cam_cal_flag);
	
	return len;
}
//static ssize_t cam_cal_proc_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
//{
     
    
   //    return 0;
//}
static struct file_operations cam_cal_proc_ops = 
{
	.write = cam_cal_proc_write,
	//.read = cam_cal_proc_read,
};
void create_cam_cal_proc_file(void)
{
       printk("create_cam_cal_proc_file\n");
	cam_cal_proc_file =
	    create_proc_entry(CAM_CAL_PROC_FILE, 0660, NULL);
	if (cam_cal_proc_file) {
		cam_cal_proc_file->proc_fops = &cam_cal_proc_ops;
	} 
	else	{
		printk("proc file create failed!");
	}
}

/* end */

#if 0
static struct ov8825_reg mode_3264x2448[] = {

{0x0103, 0x01},
{OV8825_TABLE_WAIT_MS, 5},
{0x3000, 0x16},
{0x3001, 0x00},
{0x3002, 0x6c},
{0x3003, 0xce},
{0x3004, 0xbf},
{0x3005, 0x10},
{0x3006, 0x00},
{0x3007, 0x3b},
{0x300d, 0x00},
{0x301f, 0x09},
{0x3010, 0x00},
{0x3011, 0x02},
{0x3012, 0x80},
{0x3013, 0x39},
{0x3018, 0x00},
{0x3104, 0x20},
{0x3106, 0x15},
{0x3300, 0x00},
{0x3500, 0x00},
{0x3501, 0x9a},
{0x3502, 0xa0},
{0x3503, 0x07},
{0x350b, 0x1f},
{0x3600, 0x06},
{0x3601, 0x34},
{0x3602, 0x42},
{0x3603, 0x5c},
{0x3604, 0x98},
{0x3605, 0xf5},
{0x3609, 0xb4},
{0x360a, 0x7c},
{0x360b, 0xc9},
{0x360c, 0x0b},
{0x3612, 0x00},
{0x3613, 0x02},
{0x3614, 0x0f},
{0x3615, 0x00},
{0x3616, 0x03},
{0x3617, 0xa1},
{0x361a, 0xb0},
{0x361b, 0x04},
{0x3700, 0x20},
{0x3701, 0x44},
{0x3702, 0x50},
{0x3703, 0xcc},
{0x3704, 0x19},
{0x3705, 0x14},
{0x3706, 0x4b},
{0x3707, 0x63},
{0x3708, 0x84},
{0x3709, 0x40},
{0x370a, 0x31},
{0x370b, 0x01},
{0x370c, 0x50},
{0x370d, 0x00},
{0x370e, 0x00},
{0x3711, 0x0f},
{0x3712, 0x9c},
{0x3724, 0x01},
{0x3725, 0x92},
{0x3726, 0x01},
{0x3727, 0xa9},
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x00},
{0x3804, 0x0c},
{0x3805, 0xdf},
{0x3806, 0x09},
{0x3807, 0x9b},
{0x3808, 0x0c},
{0x3809, 0xc0},
{0x380a, 0x09},
{0x380b, 0x90},
{0x380c, 0x0d},
{0x380d, 0x20},
{0x380e, 0x09},
{0x380f, 0xb0},
{0x3810, 0x00},
{0x3811, 0x10},
{0x3812, 0x00},
{0x3813, 0x06},
{0x3814, 0x11},
{0x3815, 0x11},
{0x3816, 0x02},
{0x3817, 0x40},
{0x3818, 0x00},
{0x3819, 0x40},
{0x3820, 0x80},
{0x3821, 0x16},
{0x3b1f, 0x00},
{0x3d00, 0x00},
{0x3d01, 0x00},
{0x3d02, 0x00},
{0x3d03, 0x00},
{0x3d04, 0x00},
{0x3d05, 0x00},
{0x3d06, 0x00},
{0x3d07, 0x00},
{0x3d08, 0x00},
{0x3d09, 0x00},
{0x3d0a, 0x00},
{0x3d0b, 0x00},
{0x3d0c, 0x00},
{0x3d0d, 0x00},
{0x3d0e, 0x00},
{0x3d0f, 0x00},
{0x3d10, 0x00},
{0x3d11, 0x00},
{0x3d12, 0x00},
{0x3d13, 0x00},
{0x3d14, 0x00},
{0x3d15, 0x00},
{0x3d16, 0x00},
{0x3d17, 0x00},
{0x3d18, 0x00},
{0x3d19, 0x00},
{0x3d1a, 0x00},
{0x3d1b, 0x00},
{0x3d1c, 0x00},
{0x3d1d, 0x00},
{0x3d1e, 0x00},
{0x3d1f, 0x00},
{0x3d80, 0x00},
{0x3d81, 0x00},
{0x3d84, 0x00},
{0x3f00, 0x02},
{0x3f01, 0xfc},
{0x3f05, 0x10},
{0x3f06, 0x00},
{0x3f07, 0x00},
{0x4000, 0x29},
{0x4001, 0x02},
{0x4002, 0x45},
{0x4003, 0x08},
{0x4004, 0x04},
{0x4005, 0x18},
{0x4300, 0xff},
{0x4303, 0x00},
{0x4304, 0x08},
{0x4307, 0x00},
{0x4600, 0x04},
{0x4601, 0x00},
{0x4602, 0x20},
{0x4800, 0x24},
{0x4801, 0x0f},
{0x4837, 0x1e},
{0x4843, 0x02},
{0x5000, 0x06},
{0x5001, 0x00},
{0x5002, 0x00},
{0x5068, 0x00},
{0x506a, 0x00},
{0x501f, 0x00},
{0x5780, 0xfc},
{0x5c00, 0x80},
{0x5c01, 0x00},
{0x5c02, 0x00},
{0x5c03, 0x00},
{0x5c04, 0x00},
{0x5c05, 0x00},
{0x5c06, 0x00},
{0x5c07, 0x80},
{0x5c08, 0x10},
{0x6700, 0x05},
{0x6701, 0x19},
{0x6702, 0xfd},
{0x6703, 0xd7},
{0x6704, 0xff},
{0x6705, 0xff},
{0x6800, 0x10},
{0x6801, 0x02},
{0x6802, 0x90},
{0x6803, 0x10},
{0x6804, 0x59},
{0x6900, 0x60},
{0x6901, 0x04},
{0x5800, 0x0f},
{0x5801, 0x0d},
{0x5802, 0x09},
{0x5803, 0x0a},
{0x5804, 0x0d},
{0x5805, 0x14},
{0x5806, 0x0a},
{0x5807, 0x04},
{0x5808, 0x03},
{0x5809, 0x03},
{0x580a, 0x05},
{0x580b, 0x0a},
{0x580c, 0x05},
{0x580d, 0x02},
{0x580e, 0x00},
{0x580f, 0x00},
{0x5810, 0x03},
{0x5811, 0x05},
{0x5812, 0x09},
{0x5813, 0x03},
{0x5814, 0x01},
{0x5815, 0x01},
{0x5816, 0x04},
{0x5817, 0x09},
{0x5818, 0x09},
{0x5819, 0x08},
{0x581a, 0x06},
{0x581b, 0x06},
{0x581c, 0x08},
{0x581d, 0x06},
{0x581e, 0x33},
{0x581f, 0x11},
{0x5820, 0x0e},
{0x5821, 0x0f},
{0x5822, 0x11},
{0x5823, 0x3f},
{0x5824, 0x08},
{0x5825, 0x46},
{0x5826, 0x46},
{0x5827, 0x46},
{0x5828, 0x46},
{0x5829, 0x46},
{0x582a, 0x42},
{0x582b, 0x42},
{0x582c, 0x44},
{0x582d, 0x46},
{0x582e, 0x46},
{0x582f, 0x60},
{0x5830, 0x62},
{0x5831, 0x42},
{0x5832, 0x46},
{0x5833, 0x46},
{0x5834, 0x44},
{0x5835, 0x44},
{0x5836, 0x44},
{0x5837, 0x48},
{0x5838, 0x28},
{0x5839, 0x46},
{0x583a, 0x48},
{0x583b, 0x68},
{0x583c, 0x28},
{0x583d, 0xae},
{0x5842, 0x00},
{0x5843, 0xef},
{0x5844, 0x01},
{0x5845, 0x3f},
{0x5846, 0x01},
{0x5847, 0x3f},
{0x5848, 0x00},
{0x5849, 0xd5},
{0x0100, 0x01},
    {OV8825_TABLE_WAIT_MS, 5},
	{OV8825_TABLE_END, 0x0000}
};
#endif
static struct ov8825_reg mode_3264x2448[] = {

{0x0103, 0x01},
{OV8825_TABLE_WAIT_MS, 5},
{0x3000, 0x16},
{0x3001, 0x00},
{0x3002, 0x6c},
{0x3003, 0xce},
{0x3004, 0xd8},
{0x3005, 0x00},
{0x3006, 0x10},
{0x3007, 0x3b},
{0x300d, 0x00},
{0x301f, 0x09},
{0x3010, 0x00},
{0x3011, 0x01},
{0x3012, 0x80},
{0x3013, 0x39},
{0x3018, 0x00},
{0x3104, 0x20},
//{0x3106, 0x11},
{0x3300, 0x00},
{0x3500, 0x00},
{0x3501, 0x9a},
{0x3502, 0xa0},
{0x3503, 0x07},
{0x3509, 0x00}, /* gain stuff - 350[a/b]|[4/5] */
{0x350b, 0x1f},

{0x3600, 0x06},
{0x3601, 0x33},
{0x3602, 0x42},
{0x3603, 0x5c},
{0x3604, 0x98},
{0x3605, 0xf5},
{0x3609, 0xb4},
{0x360a, 0x7c},
{0x360b, 0xc9},
{0x360c, 0x0b},
{0x3612, 0x00},
{0x3613, 0x02},
{0x3614, 0x0f},
{0x3615, 0x00},
{0x3616, 0x03},
{0x3617, 0xa1},


{0x361a, 0xb0},
{0x361b, 0x04},
{0x361c, 0x05},

{0x3700, 0x20},
{0x3701, 0x44},
{0x3702, 0x50},
{0x3703, 0xcc},
{0x3704, 0x19},
{0x3705, 0x14},
{0x3706, 0x4b},
{0x3707, 0x63},
{0x3708, 0x84},
{0x3709, 0x40},
{0x370a, 0x31},
{0x370b, 0x01},
{0x370c, 0x50},
{0x370d, 0x00},
{0x370e, 0x00},
{0x3711, 0x0f},
{0x3712, 0x9c},
{0x3724, 0x01},
{0x3725, 0x92},
{0x3726, 0x01},
{0x3727, 0xa9},
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x00},
{0x3804, 0x0c},
{0x3805, 0xdf},
{0x3806, 0x09},
{0x3807, 0x9b},
{0x3808, 0x0c},
{0x3809, 0xc0},
{0x380a, 0x09},
{0x380b, 0x90},
{0x380c, 0x0e},
{0x380d, 0x00},
{0x380e, 0x09},
{0x380f, 0xb4},
{0x3810, 0x00},
{0x3811, 0x10},
{0x3812, 0x00},
{0x3813, 0x06},
{0x3814, 0x11},
{0x3815, 0x11},
{0x3816, 0x02},
{0x3817, 0x40},
{0x3818, 0x00},
{0x3819, 0x40},
{0x3820, 0x00},
{0x3821, 0x16},
//{0x3b1f, 0x00},
{0x3d00, 0x00},
{0x3d01, 0x00},
{0x3d02, 0x00},
{0x3d03, 0x00},
{0x3d04, 0x00},
{0x3d05, 0x00},
{0x3d06, 0x00},
{0x3d07, 0x00},
{0x3d08, 0x00},
{0x3d09, 0x00},
{0x3d0a, 0x00},
{0x3d0b, 0x00},
{0x3d0c, 0x00},
{0x3d0d, 0x00},
{0x3d0e, 0x00},
{0x3d0f, 0x00},
{0x3d10, 0x00},
{0x3d11, 0x00},
{0x3d12, 0x00},
{0x3d13, 0x00},
{0x3d14, 0x00},
{0x3d15, 0x00},
{0x3d16, 0x00},
{0x3d17, 0x00},
{0x3d18, 0x00},
{0x3d19, 0x00},
{0x3d1a, 0x00},
{0x3d1b, 0x00},
{0x3d1c, 0x00},
{0x3d1d, 0x00},
{0x3d1e, 0x00},
{0x3d1f, 0x00},
{0x3d80, 0x00},
{0x3d81, 0x00},
{0x3d84, 0x00},
{0x3f00, 0x02},
{0x3f01, 0xfc},
{0x3f05, 0x10},
{0x3f06, 0x00},
{0x3f07, 0x00},
{0x4000, 0x29},
{0x4001, 0x02},
{0x4002, 0x45},
{0x4003, 0x08},
{0x4004, 0x04},
{0x4005, 0x18},
{0x4300, 0xff},
{0x4303, 0x00},
{0x4304, 0x08},
{0x4307, 0x00},
{0x4600, 0x04},
{0x4601, 0x00},
{0x4602, 0x78},
{0x4800, 0x04},
{0x4801, 0x0f},
{0x4837, 0x28},
{0x4843, 0x02},
{0x5000, 0x06},
{0x5001, 0x00},
{0x5002, 0x00},
{0x5068, 0x00},
{0x506a, 0x00},
{0x501f, 0x00},
{0x5780, 0xfc},











{0x5c00, 0x80},
{0x5c01, 0x00},
{0x5c02, 0x00},
{0x5c03, 0x00},
{0x5c04, 0x00},
{0x5c05, 0x00},
{0x5c06, 0x00},
{0x5c07, 0x80},
{0x5c08, 0x10},
{0x6700, 0x05},
{0x6701, 0x19},
{0x6702, 0xfd},
{0x6703, 0xd7},
{0x6704, 0xff},
{0x6705, 0xff},
{0x6800, 0x10},
{0x6801, 0x02},
{0x6802, 0x90},
{0x6803, 0x10},
{0x6804, 0x59},
{0x6900, 0x60},
{0x6901, 0x04},






{0x5800, 0x0f},
{0x5801, 0x0d},
{0x5802, 0x09},
{0x5803, 0x0a},
{0x5804, 0x0d},
{0x5805, 0x14},
{0x5806, 0x0a},
{0x5807, 0x04},
{0x5808, 0x03},
{0x5809, 0x03},
{0x580a, 0x05},
{0x580b, 0x0a},
{0x580c, 0x05},
{0x580d, 0x02},
{0x580e, 0x00},
{0x580f, 0x00},
{0x5810, 0x03},
{0x5811, 0x05},
{0x5812, 0x09},
{0x5813, 0x03},
{0x5814, 0x01},
{0x5815, 0x01},
{0x5816, 0x04},
{0x5817, 0x09},
{0x5818, 0x09},
{0x5819, 0x08},
{0x581a, 0x06},
{0x581b, 0x06},
{0x581c, 0x08},
{0x581d, 0x06},
{0x581e, 0x33},
{0x581f, 0x11},
{0x5820, 0x0e},
{0x5821, 0x0f},
{0x5822, 0x11},
{0x5823, 0x3f},
{0x5824, 0x08},
{0x5825, 0x46},
{0x5826, 0x46},
{0x5827, 0x46},
{0x5828, 0x46},
{0x5829, 0x46},
{0x582a, 0x42},
{0x582b, 0x42},
{0x582c, 0x44},
{0x582d, 0x46},
{0x582e, 0x46},
{0x582f, 0x60},
{0x5830, 0x62},
{0x5831, 0x42},
{0x5832, 0x46},
{0x5833, 0x46},
{0x5834, 0x44},
{0x5835, 0x44},
{0x5836, 0x44},
{0x5837, 0x48},
{0x5838, 0x28},
{0x5839, 0x46},
{0x583a, 0x48},
{0x583b, 0x68},
{0x583c, 0x28},
{0x583d, 0xae},
{0x5842, 0x00},
{0x5843, 0xef},
{0x5844, 0x01},
{0x5845, 0x3f},
{0x5846, 0x01},
{0x5847, 0x3f},
{0x5848, 0x00},
{0x5849, 0xd5},
//{0x0100, 0x01},
    {OV8825_TABLE_WAIT_MS, 5},
{OV8825_TABLE_END, 0x0000}
};

#if 0
static struct ov8825_reg mode_1920x1080[] = {
{0x0103, 0x01},
{OV8825_TABLE_WAIT_MS, 5},
{0x3000, 0x16},
{0x3001, 0x00},
{0x3002, 0x6c},
{0x3003, 0xce},
{0x3004, 0xce},
{0x3005, 0x10},
{0x3006, 0x00},
{0x3007, 0x3b},
{0x300d, 0x00},
{0x301f, 0x09},
{0x3010, 0x00},
{0x3011, 0x02},
{0x3012, 0x80},
{0x3013, 0x39},
{0x3018, 0x00},
{0x3104, 0x20},
{0x3106, 0x15},
{0x3300, 0x00},
{0x3500, 0x00},
{0x3501, 0x74},
{0x3502, 0x60},
{0x3503, 0x07},
{0x350b, 0x1f},
{0x3600, 0x06},
{0x3601, 0x34},
{0x3602, 0x42},
{0x3603, 0x5c},
{0x3604, 0x98},
{0x3605, 0xf5},
{0x3609, 0xb4},
{0x360a, 0x7c},
{0x360b, 0xc9},
{0x360c, 0x0b},
{0x3612, 0x00},
{0x3613, 0x02},
{0x3614, 0x0f},
{0x3615, 0x00},
{0x3616, 0x03},
{0x3617, 0xa1},
{0x361a, 0xb0},
{0x361b, 0x04},
{0x3700, 0x20},
{0x3701, 0x44},
{0x3702, 0x50},
{0x3703, 0xcc},
{0x3704, 0x19},
{0x3705, 0x14},
{0x3706, 0x4b},
{0x3707, 0x63},
{0x3708, 0x84},
{0x3709, 0x40},
{0x370a, 0x31},
{0x370b, 0x01},
{0x370c, 0x50},
{0x370d, 0x00},
{0x370e, 0x00},
{0x3711, 0x0f},
{0x3712, 0x9c},
{0x3724, 0x01},
{0x3725, 0x92},
{0x3726, 0x01},
{0x3727, 0xa9},
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x01},
{0x3803, 0x30},
{0x3804, 0x0c},
{0x3805, 0xdf},
{0x3806, 0x08},
{0x3807, 0x67},
{0x3808, 0x07},
{0x3809, 0x80},
{0x380a, 0x04},
{0x380b, 0x38},
{0x380c, 0x0d},
{0x380d, 0xf0},
{0x380e, 0x07},
{0x380f, 0x4c},
{0x3810, 0x00},
{0x3811, 0x10},
{0x3812, 0x00},
{0x3813, 0x06},
{0x3814, 0x11},
{0x3815, 0x11},
{0x3816, 0x02},
{0x3817, 0x40},
{0x3818, 0x00},
{0x3819, 0x40},
{0x3820, 0x80},
{0x3821, 0x16},
{0x3b1f, 0x00},
{0x3d00, 0x00},
{0x3d01, 0x00},
{0x3d02, 0x00},
{0x3d03, 0x00},
{0x3d04, 0x00},
{0x3d05, 0x00},
{0x3d06, 0x00},
{0x3d07, 0x00},
{0x3d08, 0x00},
{0x3d09, 0x00},
{0x3d0a, 0x00},
{0x3d0b, 0x00},
{0x3d0c, 0x00},
{0x3d0d, 0x00},
{0x3d0e, 0x00},
{0x3d0f, 0x00},
{0x3d10, 0x00},
{0x3d11, 0x00},
{0x3d12, 0x00},
{0x3d13, 0x00},
{0x3d14, 0x00},
{0x3d15, 0x00},
{0x3d16, 0x00},
{0x3d17, 0x00},
{0x3d18, 0x00},
{0x3d19, 0x00},
{0x3d1a, 0x00},
{0x3d1b, 0x00},
{0x3d1c, 0x00},
{0x3d1d, 0x00},
{0x3d1e, 0x00},
{0x3d1f, 0x00},
{0x3d80, 0x00},
{0x3d81, 0x00},
{0x3d84, 0x00},
{0x3f00, 0x02},
{0x3f01, 0xfc},
{0x3f05, 0x10},
{0x3f06, 0x00},
{0x3f07, 0x00},
{0x4000, 0x29},
{0x4001, 0x02},
{0x4002, 0x45},
{0x4003, 0x08},
{0x4004, 0x04},
{0x4005, 0x18},
{0x4300, 0xff},
{0x4303, 0x00},
{0x4304, 0x08},
{0x4307, 0x00},
{0x4600, 0x04},
{0x4601, 0x01},
{0x4602, 0x00},
{0x4800, 0x24}, //0x4800[5]=1 as noncontinuous clock
{0x4801, 0x0f},
{0x4837, 0x28},
{0x4843, 0x02},
{0x5000, 0x06},
{0x5001, 0x00},
{0x5002, 0x00},
{0x5068, 0x53},
{0x506a, 0x53},
{0x501f, 0x00},
{0x5780, 0xfc},
{0x5c00, 0x80},
{0x5c01, 0x00},
{0x5c02, 0x00},
{0x5c03, 0x00},
{0x5c04, 0x00},
{0x5c05, 0x00},
{0x5c06, 0x00},
{0x5c07, 0x80},
{0x5c08, 0x10},
{0x6700, 0x05},
{0x6701, 0x19},
{0x6702, 0xfd},
{0x6703, 0xd7},
{0x6704, 0xff},
{0x6705, 0xff},
{0x6800, 0x10},
{0x6801, 0x02},
{0x6802, 0x90},
{0x6803, 0x10},
{0x6804, 0x59},
{0x6900, 0x60},
{0x6901, 0x04},
{0x5800, 0x0f},
{0x5801, 0x0d},
{0x5802, 0x09},
{0x5803, 0x0a},
{0x5804, 0x0d},
{0x5805, 0x14},
{0x5806, 0x0a},
{0x5807, 0x04},
{0x5808, 0x03},
{0x5809, 0x03},
{0x580a, 0x05},
{0x580b, 0x0a},
{0x580c, 0x05},
{0x580d, 0x02},
{0x580e, 0x00},
{0x580f, 0x00},
{0x5810, 0x03},
{0x5811, 0x05},
{0x5812, 0x09},
{0x5813, 0x03},
{0x5814, 0x01},
{0x5815, 0x01},
{0x5816, 0x04},
{0x5817, 0x09},
{0x5818, 0x09},
{0x5819, 0x08},
{0x581a, 0x06},
{0x581b, 0x06},
{0x581c, 0x08},
{0x581d, 0x06},
{0x581e, 0x33},
{0x581f, 0x11},
{0x5820, 0x0e},
{0x5821, 0x0f},
{0x5822, 0x11},
{0x5823, 0x3f},
{0x5824, 0x08},
{0x5825, 0x46},
{0x5826, 0x46},
{0x5827, 0x46},
{0x5828, 0x46},
{0x5829, 0x46},
{0x582a, 0x42},
{0x582b, 0x42},
{0x582c, 0x44},
{0x582d, 0x46},
{0x582e, 0x46},
{0x582f, 0x60},
{0x5830, 0x62},
{0x5831, 0x42},
{0x5832, 0x46},
{0x5833, 0x46},
{0x5834, 0x44},
{0x5835, 0x44},
{0x5836, 0x44},
{0x5837, 0x48},
{0x5838, 0x28},
{0x5839, 0x46},
{0x583a, 0x48},
{0x583b, 0x68},
{0x583c, 0x28},
{0x583d, 0xae},
{0x5842, 0x00},
{0x5843, 0xef},
{0x5844, 0x01},
{0x5845, 0x3f},
{0x5846, 0x01},
{0x5847, 0x3f},
{0x5848, 0x00},
{0x5849, 0xd5},
{0x0100, 0x01}, //0x0100[0]=1 as start streaming
{OV8825_TABLE_WAIT_MS, 5},
	{OV8825_TABLE_END, 0x0000}
};
#endif
static struct ov8825_reg mode_1920x1080[] = {
{0x0103, 0x01},
{OV8825_TABLE_WAIT_MS, 5},
{0x3000, 0x16},
{0x3001, 0x00},
{0x3002, 0x6c},
{0x3003, 0xce},
{0x3004, 0xd4},
{0x3005, 0x00},
{0x3006, 0x00},
{0x3007, 0x3b},
{0x300d, 0x00},
{0x301f, 0x09},
{0x3010, 0x00},
{0x3011, 0x01},
{0x3012, 0x80},
{0x3013, 0x39},
{0x3018, 0x00},
{0x3104, 0x20},
{0x3106, 0x15},
{0x3300, 0x00},
{0x3500, 0x00},
{0x3501, 0x74},
{0x3502, 0x60},
{0x3503, 0x07},
{0x3509, 0x00}, /* gain stuff - 350[a/b]|[4/5] */
{0x350b, 0x1f},
{0x3600, 0x06},
{0x3601, 0x34},
{0x3602, 0x42},
{0x3603, 0x5c},
{0x3604, 0x98},
{0x3605, 0xf5},
{0x3609, 0xb4},
{0x360a, 0x7c},
{0x360b, 0xc9},
{0x360c, 0x0b},
{0x3612, 0x00},
{0x3613, 0x02},
{0x3614, 0x0f},
{0x3615, 0x00},
{0x3616, 0x03},
{0x3617, 0xa1},
{0x361a, 0xb0},
{0x361b, 0x04},
{0x361c, 0x05},
{0x3700, 0x20},
{0x3701, 0x44},
{0x3702, 0x50},
{0x3703, 0xcc},
{0x3704, 0x19},
{0x3705, 0x14},
{0x3706, 0x4b},
{0x3707, 0x63},
{0x3708, 0x84},
{0x3709, 0x40},
{0x370a, 0x31},// sensor control
{0x370b, 0x01},
{0x370c, 0x50},
{0x370d, 0x00},
{0x370e, 0x00},
{0x3711, 0x0f},
{0x3712, 0x9c},
{0x3724, 0x01},
{0x3725, 0x92},
{0x3726, 0x01},
{0x3727, 0xa9},

{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x01},
{0x3803, 0x30},
{0x3804, 0x0c},
{0x3805, 0xdf},
{0x3806, 0x08},
{0x3807, 0x67},
{0x3808, 0x07},
{0x3809, 0x80},
{0x380a, 0x04},
{0x380b, 0x38},
{0x380c, 0x0d},
//{0x380d, 0xf0},
//{0x380d, 0xd0},
{0x380d, 0xe4},
{0x380e, 0x07},
{0x380f, 0x4c},
{0x3810, 0x00},
{0x3811, 0x10},
{0x3812, 0x00},
{0x3813, 0x06},
{0x3814, 0x11},
{0x3815, 0x11},
{0x3816, 0x02},
{0x3817, 0x40},
{0x3818, 0x00},
{0x3819, 0x40},
{0x3820, 0x80},
{0x3821, 0x16},
{0x3b1f, 0x00},
{0x3d00, 0x00},
{0x3d01, 0x00},
{0x3d02, 0x00},
{0x3d03, 0x00},
{0x3d04, 0x00},
{0x3d05, 0x00},
{0x3d06, 0x00},
{0x3d07, 0x00},
{0x3d08, 0x00},
{0x3d09, 0x00},
{0x3d0a, 0x00},
{0x3d0b, 0x00},
{0x3d0c, 0x00},
{0x3d0d, 0x00},
{0x3d0e, 0x00},
{0x3d0f, 0x00},
{0x3d10, 0x00},
{0x3d11, 0x00},
{0x3d12, 0x00},
{0x3d13, 0x00},
{0x3d14, 0x00},
{0x3d15, 0x00},
{0x3d16, 0x00},
{0x3d17, 0x00},
{0x3d18, 0x00},
{0x3d19, 0x00},
{0x3d1a, 0x00},
{0x3d1b, 0x00},
{0x3d1c, 0x00},
{0x3d1d, 0x00},
{0x3d1e, 0x00},
{0x3d1f, 0x00},
{0x3d80, 0x00},
{0x3d81, 0x00},
{0x3d84, 0x00},
{0x3f00, 0x02},
{0x3f01, 0xfc},
{0x3f05, 0x10},
{0x3f06, 0x00},
{0x3f07, 0x00},
{0x4000, 0x29},
{0x4001, 0x02},
{0x4002, 0x45},
{0x4003, 0x08},
{0x4004, 0x04},
{0x4005, 0x18},
{0x4300, 0xff},
{0x4303, 0x00},
{0x4304, 0x08},
{0x4307, 0x00},
{0x4600, 0x04},
{0x4601, 0x01},
{0x4602, 0x00},
{0x4800, 0x24}, //0x4800[5]=1 as noncontinuous clock
{0x4801, 0x0f},
{0x4837, 0x28},
{0x4843, 0x02},
{0x5000, 0x06},
{0x5001, 0x00},
{0x5002, 0x00},
{0x5068, 0x53},
{0x506a, 0x53},
{0x501f, 0x00},
{0x5780, 0xfc},
{0x5c00, 0x80},
{0x5c01, 0x00},
{0x5c02, 0x00},
{0x5c03, 0x00},
{0x5c04, 0x00},
{0x5c05, 0x00},
{0x5c06, 0x00},
{0x5c07, 0x80},
{0x5c08, 0x10},
{0x6700, 0x05},
{0x6701, 0x19},
{0x6702, 0xfd},
{0x6703, 0xd7},
{0x6704, 0xff},
{0x6705, 0xff},
{0x6800, 0x10},
{0x6801, 0x02},
{0x6802, 0x90},
{0x6803, 0x10},
{0x6804, 0x59},
{0x6900, 0x60},
{0x6901, 0x04},
{0x5800, 0x0f},
{0x5801, 0x0d},
{0x5802, 0x09},
{0x5803, 0x0a},
{0x5804, 0x0d},
{0x5805, 0x14},
{0x5806, 0x0a},
{0x5807, 0x04},
{0x5808, 0x03},
{0x5809, 0x03},
{0x580a, 0x05},
{0x580b, 0x0a},
{0x580c, 0x05},
{0x580d, 0x02},
{0x580e, 0x00},
{0x580f, 0x00},
{0x5810, 0x03},
{0x5811, 0x05},
{0x5812, 0x09},
{0x5813, 0x03},
{0x5814, 0x01},
{0x5815, 0x01},
{0x5816, 0x04},
{0x5817, 0x09},
{0x5818, 0x09},
{0x5819, 0x08},
{0x581a, 0x06},
{0x581b, 0x06},
{0x581c, 0x08},
{0x581d, 0x06},
{0x581e, 0x33},
{0x581f, 0x11},
{0x5820, 0x0e},
{0x5821, 0x0f},
{0x5822, 0x11},
{0x5823, 0x3f},
{0x5824, 0x08},
{0x5825, 0x46},
{0x5826, 0x46},
{0x5827, 0x46},
{0x5828, 0x46},
{0x5829, 0x46},
{0x582a, 0x42},
{0x582b, 0x42},
{0x582c, 0x44},
{0x582d, 0x46},
{0x582e, 0x46},
{0x582f, 0x60},
{0x5830, 0x62},
{0x5831, 0x42},
{0x5832, 0x46},
{0x5833, 0x46},
{0x5834, 0x44},
{0x5835, 0x44},
{0x5836, 0x44},
{0x5837, 0x48},
{0x5838, 0x28},
{0x5839, 0x46},
{0x583a, 0x48},
{0x583b, 0x68},
{0x583c, 0x28},
{0x583d, 0xae},
{0x5842, 0x00},
{0x5843, 0xef},
{0x5844, 0x01},
{0x5845, 0x3f},
{0x5846, 0x01},
{0x5847, 0x3f},
{0x5848, 0x00},
{0x5849, 0xd5},
//{0x0100, 0x01}, //0x0100[0]=1 as start streaming
{OV8825_TABLE_WAIT_MS, 5},
{OV8825_TABLE_END, 0x0000}
};

#if 0
static struct ov8825_reg mode_1632x1224[] = {
	
{0x0103, 0x01},
{OV8825_TABLE_WAIT_MS, 5},
{0x3000, 0x16},
{0x3001, 0x00},
{0x3002, 0x6c},
{0x3003, 0xce},
{0x3004, 0xce},
{0x3005, 0x10},
{0x3006, 0x10},
{0x3007, 0x3b},
{0x300d, 0x00},
{0x301f, 0x09},
{0x3010, 0x00},
{0x3011, 0x02},
{0x3012, 0x81},
{0x3013, 0x39},
{0x3018, 0x00},
{0x3104, 0x20},
{0x3106, 0x11},
{0x3300, 0x00},
{0x3500, 0x00},
{0x3501, 0x4e},
{0x3502, 0xa0},
{0x3503, 0x07},
{0x350b, 0x1f},
{0x3600, 0x07},
{0x3601, 0x33},
{0x3602, 0x42},
{0x3603, 0x5c},
{0x3604, 0x98},
{0x3605, 0xf5},
{0x3609, 0xb4},
{0x360a, 0x7c},
{0x360b, 0xc9},
{0x360c, 0x0b},
{0x3612, 0x00},
{0x3613, 0x02},
{0x3614, 0x0f},
{0x3615, 0x00},
{0x3616, 0x03},
{0x3617, 0xa1},
{0x361a, 0xb0},
{0x361b, 0x04},
{0x3700, 0x10},
{0x3701, 0x44},
{0x3702, 0x28},
{0x3703, 0x6c},
{0x3704, 0x8d},
{0x3705, 0x0a},
{0x3706, 0x27},
{0x3707, 0x63},
{0x3708, 0x40},
{0x3709, 0x20},
{0x370a, 0x33},
{0x370b, 0x01},
{0x370c, 0x50},
{0x370d, 0x00},
{0x370e, 0x08},
{0x3711, 0x07},
{0x3712, 0x4e},
{0x3724, 0x00},
{0x3725, 0xd4},
{0x3726, 0x00},
{0x3727, 0xe1},
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x00},
{0x3804, 0x0c},
{0x3805, 0xdf},
{0x3806, 0x09},
{0x3807, 0x9b},
{0x3808, 0x06},
{0x3809, 0x60},
{0x380a, 0x04},
{0x380b, 0xc8},
{0x380c, 0x0d},
{0x380d, 0xbc},
{0x380e, 0x04},
{0x380f, 0xf0},
{0x3810, 0x00},
{0x3811, 0x08},
{0x3812, 0x00},
{0x3813, 0x04},
{0x3814, 0x31},
{0x3815, 0x31},
{0x3816, 0x02},
{0x3817, 0x40},
{0x3818, 0x00},
{0x3819, 0x40},
{0x3820, 0x80},
{0x3821, 0x17},
{0x3b1f, 0x00},
{0x3d00, 0x00},
{0x3d01, 0x00},
{0x3d02, 0x00},
{0x3d03, 0x00},
{0x3d04, 0x00},
{0x3d05, 0x00},
{0x3d06, 0x00},
{0x3d07, 0x00},
{0x3d08, 0x00},
{0x3d09, 0x00},
{0x3d0a, 0x00},
{0x3d0b, 0x00},
{0x3d0c, 0x00},
{0x3d0d, 0x00},
{0x3d0e, 0x00},
{0x3d0f, 0x00},
{0x3d10, 0x00},
{0x3d11, 0x00},
{0x3d12, 0x00},
{0x3d13, 0x00},
{0x3d14, 0x00},
{0x3d15, 0x00},
{0x3d16, 0x00},
{0x3d17, 0x00},
{0x3d18, 0x00},
{0x3d19, 0x00},
{0x3d1a, 0x00},
{0x3d1b, 0x00},
{0x3d1c, 0x00},
{0x3d1d, 0x00},
{0x3d1e, 0x00},
{0x3d1f, 0x00},
{0x3d80, 0x00},
{0x3d81, 0x00},
{0x3d84, 0x00},
{0x3f00, 0x00},
{0x3f01, 0xfc},
{0x3f05, 0x10},
{0x3f06, 0x00},
{0x3f07, 0x00},
{0x4000, 0x29},
{0x4001, 0x02},
{0x4002, 0x45},
{0x4003, 0x08},
{0x4004, 0x04},
{0x4005, 0x18},
{0x4300, 0xff},
{0x4303, 0x00},
{0x4304, 0x08},
{0x4307, 0x00},
{0x4600, 0x04},
{0x4601, 0x00},
{0x4602, 0x78},
{0x4800, 0x24},
{0x4801, 0x0f},
{0x4837, 0x28},
{0x4843, 0x02},
{0x5000, 0x06},
{0x5001, 0x00},
{0x5002, 0x00},
{0x5068, 0x00},
{0x506a, 0x00},
{0x501f, 0x00},
{0x5780, 0xfc},
{0x5c00, 0x80},
{0x5c01, 0x00},
{0x5c02, 0x00},
{0x5c03, 0x00},
{0x5c04, 0x00},
{0x5c05, 0x00},
{0x5c06, 0x00},
{0x5c07, 0x80},
{0x5c08, 0x10},
{0x6700, 0x05},
{0x6701, 0x19},
{0x6702, 0xfd},
{0x6703, 0xd7},
{0x6704, 0xff},
{0x6705, 0xff},
{0x6800, 0x10},
{0x6801, 0x02},
{0x6802, 0x90},
{0x6803, 0x10},
{0x6804, 0x59},
{0x6900, 0x60},
{0x6901, 0x05},
//{0x0100, 0x01},
{0x5800, 0x0f},
{0x5801, 0x0d},
{0x5802, 0x09},
{0x5803, 0x0a},
{0x5804, 0x0d},
{0x5805, 0x14},
{0x5806, 0x0a},
{0x5807, 0x04},
{0x5808, 0x03},
{0x5809, 0x03},
{0x580a, 0x05},
{0x580b, 0x0a},
{0x580c, 0x05},
{0x580d, 0x02},
{0x580e, 0x00},
{0x580f, 0x00},
{0x5810, 0x03},
{0x5811, 0x05},
{0x5812, 0x09},
{0x5813, 0x03},
{0x5814, 0x01},
{0x5815, 0x01},
{0x5816, 0x04},
{0x5817, 0x09},
{0x5818, 0x09},
{0x5819, 0x08},
{0x581a, 0x06},
{0x581b, 0x06},
{0x581c, 0x08},
{0x581d, 0x06},
{0x581e, 0x33},
{0x581f, 0x11},
{0x5820, 0x0e},
{0x5821, 0x0f},
{0x5822, 0x11},
{0x5823, 0x3f},
{0x5824, 0x08},
{0x5825, 0x46},
{0x5826, 0x46},
{0x5827, 0x46},
{0x5828, 0x46},
{0x5829, 0x46},
{0x582a, 0x42},
{0x582b, 0x42},
{0x582c, 0x44},
{0x582d, 0x46},
{0x582e, 0x46},
{0x582f, 0x60},
{0x5830, 0x62},
{0x5831, 0x42},
{0x5832, 0x46},
{0x5833, 0x46},
{0x5834, 0x44},
{0x5835, 0x44},
{0x5836, 0x44},
{0x5837, 0x48},
{0x5838, 0x28},
{0x5839, 0x46},
{0x583a, 0x48},
{0x583b, 0x68},
{0x583c, 0x28},
{0x583d, 0xae},
{0x5842, 0x00},
{0x5843, 0xef},
{0x5844, 0x01},
{0x5845, 0x3f},
{0x5846, 0x01},
{0x5847, 0x3f},
{0x5848, 0x00},
{0x5849, 0xd5},
{0x0100, 0x01},
    {OV8825_TABLE_WAIT_MS, 5},
	{OV8825_TABLE_END, 0x0000}
};
#endif
static struct ov8825_reg mode_1632x1224[] = {

{0x0103, 0x01},
{OV8825_TABLE_WAIT_MS, 5},
{0x3000, 0x16},
{0x3001, 0x00},
{0x3002, 0x6c},
{0x3003, 0xce},
{0x3004, 0xd4},
{0x3005, 0x00},
{0x3006, 0x10},
{0x3007, 0x3b},
{0x300d, 0x00},
{0x301f, 0x09},
{0x3010, 0x00},
{0x3011, 0x01},
{0x3012, 0x80},
{0x3013, 0x39},
{0x3018, 0x00},
{0x3104, 0x20},
{0x3106, 0x15},
{0x3300, 0x00},
{0x3500, 0x00},
{0x3501, 0x4e},
{0x3502, 0xa0},
{0x3503, 0x07},
{0x3509, 0x00}, /* gain stuff - 350[a/b]|[4/5] */
{0x350b, 0x1f},
{0x3600, 0x07},
{0x3601, 0x34},
{0x3602, 0x42},
{0x3603, 0x5c},
{0x3604, 0x98},
{0x3605, 0xf5},
{0x3609, 0xb4},
{0x360a, 0x7c},
{0x360b, 0xc9},
{0x360c, 0x0b},
{0x3612, 0x00},
{0x3613, 0x02},
{0x3614, 0x0f},
{0x3615, 0x00},
{0x3616, 0x03},
{0x3617, 0xa1},
{0x361a, 0xb0},
{0x361b, 0x04},
{0x361c, 0x05},
{0x3700, 0x20},
{0x3701, 0x44},
{0x3702, 0x50},
{0x3703, 0xcc},
{0x3704, 0x19},
{0x3705, 0x14},
{0x3706, 0x4b},
{0x3707, 0x63},
{0x3708, 0x84},
{0x3709, 0x40},
{0x370a, 0x33},
{0x370b, 0x01},
{0x370c, 0x50},
{0x370d, 0x00},
{0x370e, 0x08},
{0x3711, 0x0f},
{0x3712, 0x9c},
{0x3724, 0x01},
{0x3725, 0x92},
{0x3726, 0x01},
{0x3727, 0xa9},
{0x3800, 0x00},
{0x3801, 0x00},
{0x3802, 0x00},
{0x3803, 0x00},
{0x3804, 0x0c},
{0x3805, 0xdf},
{0x3806, 0x09},
{0x3807, 0x9b},
{0x3808, 0x06},
{0x3809, 0x60},
{0x380a, 0x04},
{0x380b, 0xc8},
{0x380c, 0x0d},
{0x380d, 0xbc},
{0x380e, 0x04},
{0x380f, 0xf0},
{0x3810, 0x00},
{0x3811, 0x08},
{0x3812, 0x00},
{0x3813, 0x04},
{0x3814, 0x31},
{0x3815, 0x31},
{0x3816, 0x02},
{0x3817, 0x40},
{0x3818, 0x00},
{0x3819, 0x40},
{0x3820, 0x80},
{0x3821, 0x17},
{0x3b1f, 0x00},
{0x3d00, 0x00},
{0x3d01, 0x00},
{0x3d02, 0x00},
{0x3d03, 0x00},
{0x3d04, 0x00},
{0x3d05, 0x00},
{0x3d06, 0x00},
{0x3d07, 0x00},
{0x3d08, 0x00},
{0x3d09, 0x00},
{0x3d0a, 0x00},
{0x3d0b, 0x00},
{0x3d0c, 0x00},
{0x3d0d, 0x00},
{0x3d0e, 0x00},
{0x3d0f, 0x00},
{0x3d10, 0x00},
{0x3d11, 0x00},
{0x3d12, 0x00},
{0x3d13, 0x00},
{0x3d14, 0x00},
{0x3d15, 0x00},
{0x3d16, 0x00},
{0x3d17, 0x00},
{0x3d18, 0x00},
{0x3d19, 0x00},
{0x3d1a, 0x00},
{0x3d1b, 0x00},
{0x3d1c, 0x00},
{0x3d1d, 0x00},
{0x3d1e, 0x00},
{0x3d1f, 0x00},
{0x3d80, 0x00},
{0x3d81, 0x00},
{0x3d84, 0x00},
{0x3f00, 0x00},
{0x3f01, 0xfc},
{0x3f05, 0x10},
{0x3f06, 0x00},
{0x3f07, 0x00},
{0x4000, 0x29},
{0x4001, 0x02},
{0x4002, 0x45},
{0x4003, 0x08},
{0x4004, 0x04},
{0x4005, 0x18},
{0x4300, 0xff},
{0x4303, 0x00},
{0x4304, 0x08},
{0x4307, 0x00},
{0x4600, 0x04},
{0x4601, 0x00},
{0x4602, 0x30},
{0x4800, 0x04},//continue bit 5 = 0;
{0x4801, 0x0f},
{0x4837, 0x28},
{0x4843, 0x02},
{0x5000, 0x06},
{0x5001, 0x00},
{0x5002, 0x00},
{0x5068, 0x00},
{0x506a, 0x00},
{0x501f, 0x00},
{0x5780, 0xfc},
{0x5c00, 0x80},
{0x5c01, 0x00},
{0x5c02, 0x00},
{0x5c03, 0x00},
{0x5c04, 0x00},
{0x5c05, 0x00},
{0x5c06, 0x00},
{0x5c07, 0x80},
{0x5c08, 0x10},
{0x6700, 0x05},
{0x6701, 0x19},
{0x6702, 0xfd},
{0x6703, 0xd7},
{0x6704, 0xff},
{0x6705, 0xff},
{0x6800, 0x10},
{0x6801, 0x02},
{0x6802, 0x90},
{0x6803, 0x10},
{0x6804, 0x59},
{0x6900, 0x60},
{0x6901, 0x05},
//{0x0100, 0x01},
{0x5800, 0x0f},
{0x5801, 0x0d},
{0x5802, 0x09},
{0x5803, 0x0a},
{0x5804, 0x0d},
{0x5805, 0x14},
{0x5806, 0x0a},
{0x5807, 0x04},
{0x5808, 0x03},
{0x5809, 0x03},
{0x580a, 0x05},
{0x580b, 0x0a},
{0x580c, 0x05},
{0x580d, 0x02},
{0x580e, 0x00},
{0x580f, 0x00},
{0x5810, 0x03},
{0x5811, 0x05},
{0x5812, 0x09},
{0x5813, 0x03},
{0x5814, 0x01},
{0x5815, 0x01},
{0x5816, 0x04},
{0x5817, 0x09},
{0x5818, 0x09},
{0x5819, 0x08},
{0x581a, 0x06},
{0x581b, 0x06},
{0x581c, 0x08},
{0x581d, 0x06},
{0x581e, 0x33},
{0x581f, 0x11},
{0x5820, 0x0e},
{0x5821, 0x0f},
{0x5822, 0x11},
{0x5823, 0x3f},
{0x5824, 0x08},
{0x5825, 0x46},
{0x5826, 0x46},
{0x5827, 0x46},
{0x5828, 0x46},
{0x5829, 0x46},
{0x582a, 0x42},
{0x582b, 0x42},
{0x582c, 0x44},
{0x582d, 0x46},
{0x582e, 0x46},
{0x582f, 0x60},
{0x5830, 0x62},
{0x5831, 0x42},
{0x5832, 0x46},
{0x5833, 0x46},
{0x5834, 0x44},
{0x5835, 0x44},
{0x5836, 0x44},
{0x5837, 0x48},
{0x5838, 0x28},
{0x5839, 0x46},
{0x583a, 0x48},
{0x583b, 0x68},
{0x583c, 0x28},
{0x583d, 0xae},
{0x5842, 0x00},
{0x5843, 0xef},
{0x5844, 0x01},
{0x5845, 0x3f},
{0x5846, 0x01},
{0x5847, 0x3f},
{0x5848, 0x00},
{0x5849, 0xd5},
//{0x0100, 0x01},
    {OV8825_TABLE_WAIT_MS, 5},
{OV8825_TABLE_END, 0x0000}
};

enum {
	OV8825_MODE_3264x2448,
	OV8825_MODE_1920x1080,
	OV8825_MODE_1632x1224,
};


static struct ov8825_reg *mode_table[] = {
	[OV8825_MODE_3264x2448] = mode_3264x2448,
	[OV8825_MODE_1920x1080] = mode_1920x1080,
	[OV8825_MODE_1632x1224] = mode_1632x1224,
};

static inline void ov8825_get_frame_length_regs(struct ov8825_reg *regs,
						u32 frame_length)
{
	regs->addr = 0x380E;
	regs->val = (frame_length >> 8) & 0xFF;
	(regs + 1)->addr = 0x380F;
	(regs + 1)->val = (frame_length) & 0xFF;
}

static inline void ov8825_get_coarse_time_regs(struct ov8825_reg *regs,
					       u32 coarse_time)
{
	regs->addr = 0x3500;
	regs->val = (coarse_time >> 12) & 0xFF;
	(regs + 1)->addr = 0x3501;
	(regs + 1)->val = (coarse_time >> 4) & 0xFF;
	(regs + 2)->addr = 0x3502;
	(regs + 2)->val = (coarse_time & 0xf) << 4;
}

static inline void ov8825_get_gain_reg(struct ov8825_reg *regs, u16 gain)
{
	regs->addr = 0x350a;
	regs->val = (gain >> 8) & 0x07;
	(regs + 1)->addr = 0x350b;
	(regs + 1)->val = (gain) & 0xff;
}

static int ov8825_read_reg(u16 addr, u8 *val)
{
    return ov8825_i2c_read_reg(NULL,addr, val);
#if 0
	int err;
	struct i2c_msg msg[2];
	unsigned char data[3];

	if (!client->adapter)
		return -ENODEV;

	msg[0].addr = client->addr;
	msg[0].flags = 0;
	msg[0].len = 2;
	msg[0].buf = data;

	/* high byte goes out first */
	data[0] = (u8) (addr >> 8);;
	data[1] = (u8) (addr & 0xff);

	msg[1].addr = client->addr;
	msg[1].flags = I2C_M_RD;
	msg[1].len = 1;
	msg[1].buf = data + 2;

	err = i2c_transfer(client->adapter, msg, 2);

	if (err != 2)

		return -EINVAL;

	*val = data[2];

	return 0;
#endif
}

static int ov8825_write_reg(u16 addr, u8 val)
{
    return ov8825_i2c_write_reg(NULL,addr, val);
#if 0
	int err;
	struct i2c_msg msg;
	unsigned char data[3];
	int retry = 0;

	if (!client->adapter)
		return -ENODEV;

	data[0] = (u8) (addr >> 8);;
	data[1] = (u8) (addr & 0xff);
	data[2] = (u8) (val & 0xff);

	msg.addr = client->addr;
	msg.flags = 0;
	msg.len = 3;
	msg.buf = data;

	do {
		err = i2c_transfer(client->adapter, &msg, 1);
		if (err == 1)
			return 0;
		retry++;
		pr_err("ov8825: i2c transfer failed, retrying %x %x\n",
		       addr, val);

		msleep(3);
	} while (retry <= OV8825_MAX_RETRIES);

	return err;
#endif
}

static int ov8825_write_table(const struct ov8825_reg table[],
			      const struct ov8825_reg override_list[],
			      int num_override_regs)
{
	int err;
	const struct ov8825_reg *next;
	int i;
	u16 val;

	for (next = table; next->addr != OV8825_TABLE_END; next++) {
		if (next->addr == OV8825_TABLE_WAIT_MS) {
			msleep(next->val);
			continue;
		}


		val = next->val;

		/* When an override list is passed in, replace the reg */
		/* value to write if the reg is in the list            */
		if (override_list) {
			for (i = 0; i < num_override_regs; i++) {
				if (next->addr == override_list[i].addr) {
					val = override_list[i].val;
					break;
				}
			}
		}

		err = ov8825_write_reg(next->addr, val);
		if (err)
			return err;
	}
	return 0;
}
/* OTP */
 int BG_Ratio_Typical = 0x4b;
int RG_Ratio_Typical  = 0x4b;
struct otp_struct {
	u8 module_integrator_id;
	u8 lens_id;
	u8 rg_ratio;
	u8 bg_ratio;
	u8 user_data[3];
	u8 light_rg;
	u8 light_bg;
	u8 lenc[62];
};
int check_otp_wb(int index)
{
	int  i;
	u8 flag;
	//int 
	 u16 address;
	int ret;

	// select bank 0
	ov8825_i2c_write_reg(NULL,0x3d84, 0x08);
	
	// read otp into buffer
	ov8825_i2c_write_reg(NULL,0x3d81, 0x01);
	
     //  mdelay(100);
	// read flag
	address = 0x3d05 + index*9;
	//flag = 
	#if OV8825_PRINT
	printk("check_otp_wb   address=%x\n",address);
	#endif
	ret = ov8825_i2c_read_reg(NULL,address,&flag);
	#if OV8825_PRINT
	printk("check_otp_wb  ret=%d\n",ret);
	printk("check_otp_wb  flag=%d\n",flag);
	#endif
	// disable otp read
	ov8825_i2c_write_reg(NULL,0x3d81, 0x00);

	// clear otp buffer
	for (i=0;i<32;i++) {
		ov8825_i2c_write_reg(NULL,0x3d00 + i, 0x00);
	}

	if (!flag) {
		printk("check_otp_wb  if (!flag) \n");
		return 0;
	}
	else if ((!(flag & 0x80)) && (flag & 0x7f)) {
		printk("check_otp_wb success \n");
		return 2;
	}
	else {
		printk("check_otp_wb  else \n");
		return 1;
	}
}
// index: index of otp group. (0, 1, 2)
// return: 	0, group index is empty
//		1, group index has invalid data
//		2, group index has valid data
int check_otp_lenc(int index)
{
	u8 flag, i;
	int address;

	// select bank: index*2+1
	ov8825_i2c_write_reg(NULL,0x3d84, 0x09 + index*2);

	// read otp into buffer
	ov8825_i2c_write_reg(NULL,0x3d81, 0x01);

	// read flag
	address = 0x3d00;
	 ov8825_i2c_read_reg(NULL,address,&flag);
	flag = flag & 0xc0;

	// disable otp read
	ov8825_i2c_write_reg(NULL,0x3d81, 0x00);

	// clear otp buffer
	for (i=0;i<32;i++) {
		ov8825_i2c_write_reg(NULL,0x3d00 + i, 0x00);
	}

	if (!flag) {
		printk("check_otp_lencif (!flag) \n ");
		return 0;
	}
	else if ((!(flag & 0x80)) && (flag & 0x7f)) {
		printk("check_otp_lencs success )\n ");
		return 2;
	}
	else {
		printk("check_otp_lenc  else\n ");
		return 1;
	}
}

// index: index of otp group. (0, 1, 2)
// otp_ptr: pointer of otp_struct
// return: 	0, 
int read_otp_wb(int index, struct otp_struct * otp_ptr)
{
	int i;
	int address;

	// select bank 0
	ov8825_i2c_write_reg(NULL,0x3d84, 0x08);

	// read otp into buffer
	ov8825_i2c_write_reg(NULL,0x3d81, 0x01);

	address = 0x3d05 + index*9;
	  ov8825_i2c_read_reg(NULL,address,&(*otp_ptr).module_integrator_id);
	  ov8825_i2c_read_reg(NULL,address + 1,&(*otp_ptr).lens_id);
	 ov8825_i2c_read_reg(NULL,address + 2,&(*otp_ptr).rg_ratio);
	ov8825_i2c_read_reg(NULL,address + 3,&(*otp_ptr).bg_ratio);
	 ov8825_i2c_read_reg(NULL,address + 4,&(*otp_ptr).user_data[0]);
	 ov8825_i2c_read_reg(NULL,address + 5,&(*otp_ptr).user_data[1] );
	 ov8825_i2c_read_reg(NULL,address + 6,&(*otp_ptr).user_data[2]);
	ov8825_i2c_read_reg(NULL,address + 7,&(*otp_ptr).light_rg);
	ov8825_i2c_read_reg(NULL,address + 8,&(*otp_ptr).light_bg);
	
	// disable otp read
	ov8825_i2c_write_reg(NULL,0x3d81, 0x00);

	// clear otp buffer
	for (i=0;i<32;i++) {
		ov8825_i2c_write_reg(NULL,0x3d00 + i, 0x00);
	}

	return 0;	
}

// index: index of otp group. (0, 1, 2)
// otp_ptr: pointer of otp_struct
// return: 	0, 
int read_otp_lenc(int index, struct otp_struct * otp_ptr)
{
	int bank, i;
	int address;

	// select bank: index*2+1
	bank = index*2 + 1;
	ov8825_i2c_write_reg(NULL,0x3d84, bank + 0x08);

	// read otp into buffer
	ov8825_i2c_write_reg(NULL,0x3d81, 0x01);

	address = 0x3d01;
	for(i=0;i<31;i++) {
		ov8825_i2c_read_reg(NULL,address,&(* otp_ptr).lenc[i]);
		address++;
	}
	
	// disable otp read
	ov8825_i2c_write_reg(NULL,0x3d81, 0x00);

	// clear otp buffer
	for (i=0;i<32;i++) {
		ov8825_i2c_write_reg(NULL,0x3d00 + i, 0x00);
	}

	// select next bank
	bank++;
	ov8825_i2c_write_reg(NULL,0x3d84, bank + 0x08);

	// read otp
	ov8825_i2c_write_reg(NULL,0x3d81, 0x01);

	address = 0x3d00;
	for(i=31;i<62;i++) {
		ov8825_i2c_read_reg(NULL,address,&(* otp_ptr).lenc[i]);
		address++;
	}

	// disable otp read
	ov8825_i2c_write_reg(NULL,0x3d81, 0x00);

	// clear otp buffer
	for (i=0;i<32;i++) {
		ov8825_i2c_write_reg(NULL,0x3d00 + i, 0x00);
	}

	return 0;	
}
// R_gain, sensor red gain of AWB, 0x400 =1
// G_gain, sensor green gain of AWB, 0x400 =1
// B_gain, sensor blue gain of AWB, 0x400 =1
// return 0;
int update_awb_gain(int R_gain, int G_gain, int B_gain)
{
	if (R_gain>0x400) {
		#if OV8825_PRINT
		printk("  (R_gain>0x400) \n ");
		#endif
		ov8825_i2c_write_reg(NULL,0x3400, R_gain>>8);
		ov8825_i2c_write_reg(NULL,0x3401, R_gain & 0x00ff);
	}

	if (G_gain>0x400) {
		#if OV8825_PRINT
		printk("  (G_gain>0x400) \n ");
		#endif
		ov8825_i2c_write_reg(NULL,0x3402, G_gain>>8);
		ov8825_i2c_write_reg(NULL,0x3403, G_gain & 0x00ff);
	}

	if (B_gain>0x400) {
		#if OV8825_PRINT
		printk("  (B_gain>0x400) \n  ");
		#endif
		ov8825_i2c_write_reg(NULL,0x3404, B_gain>>8);
		ov8825_i2c_write_reg(NULL,0x3405, B_gain & 0x00ff);
	}
	return 0;
}

// otp_ptr: pointer of otp_struct
int update_lenc(struct otp_struct * otp_ptr)
{
	int i, temp;
	u8 reg;
	/*  temp = 0x80 | (*otp_ptr).lenc[0];
	ov8825_i2c_write_reg(NULL,0x5800, temp);*/
	ov8825_i2c_read_reg(NULL,0x5000,&reg);
	temp = 0x80 |reg;
	ov8825_i2c_write_reg(NULL,0x5000, temp);

	for(i=0;i<62;i++) {
		ov8825_i2c_write_reg(NULL,0x5800 + i, (*otp_ptr).lenc[i]);
	}

	return 0;
}

// call this function after OV8820 initialization
// return value: 0 update success
//		1, no OTP
int update_otp_wb(void)
{
	struct otp_struct current_otp;
	int i;
	int otp_index;
	int temp;
	int R_gain, G_gain, B_gain, G_gain_R, G_gain_B;
	int rg,bg;


	// R/G and B/G of current camera module is read out from sensor OTP
	// check first OTP with valid data
	for(i=0;i<3;i++) {
		temp = check_otp_wb(i);
		if (temp == 2) {
			otp_index = i;
			break;
		}
	}

	if (i==3) {
		// no valid wb OTP data
		printk(" no valid wb OTP data\n");
		return 1;
	}

	read_otp_wb(otp_index, &current_otp);

	if(current_otp.light_rg==0) {
		// no light source information in OTP, light factor = 1
		rg = current_otp.rg_ratio;
	}
	else {
		rg = current_otp.rg_ratio * ((current_otp.light_rg +128) / 256);
	}
	
	if(current_otp.light_bg==0) {
		// not light source information in OTP, light factor = 1
		bg = current_otp.bg_ratio;
	}
	else {
		bg = current_otp.bg_ratio * ((current_otp.light_bg +128) / 256);
	}

	//calculate G gain
	//0x400 = 1x gain
	if(bg < BG_Ratio_Typical) {
		if (rg< RG_Ratio_Typical) {
			// current_otp.bg_ratio < BG_Ratio_typical &&  
			// current_otp.rg_ratio < RG_Ratio_typical
   			G_gain = 0x400;
			B_gain = 0x400 * BG_Ratio_Typical / bg;
    		R_gain = 0x400 * RG_Ratio_Typical / rg; 
		}
		else {
			// current_otp.bg_ratio < BG_Ratio_typical &&  
			// current_otp.rg_ratio >= RG_Ratio_typical
    		R_gain = 0x400;
   	 		G_gain = 0x400 * rg / RG_Ratio_Typical;
    		B_gain = G_gain * BG_Ratio_Typical /bg;
		}
	}
	else {
		if (rg < RG_Ratio_Typical) {
			// current_otp.bg_ratio >= BG_Ratio_typical &&  
			// current_otp.rg_ratio < RG_Ratio_typical
    		B_gain = 0x400;
    		G_gain = 0x400 * bg / BG_Ratio_Typical;
    		R_gain = G_gain * RG_Ratio_Typical / rg;
		}
		else {
			// current_otp.bg_ratio >= BG_Ratio_typical &&  
			// current_otp.rg_ratio >= RG_Ratio_typical
    		G_gain_B = 0x400 * bg / BG_Ratio_Typical;
   	 		G_gain_R = 0x400 * rg / RG_Ratio_Typical;

    		if(G_gain_B > G_gain_R ) {
        				B_gain = 0x400;
        				G_gain = G_gain_B;
 	     			R_gain = G_gain * RG_Ratio_Typical /rg;
  			}
    		else {
        			R_gain = 0x400;
       				G_gain = G_gain_R;
        			B_gain = G_gain * BG_Ratio_Typical / bg;
			}
    	}    
	}

	update_awb_gain(R_gain, G_gain, B_gain);

	return 0;

}

// call this function after OV8820 initialization
// return value: 0 update success
//		1, no OTP
int update_otp_lenc(void)
{
	struct otp_struct current_otp;
	int i;
	int otp_index;
	int temp;

	// check first lens correction OTP with valid data
	for(i=0;i<3;i++) {
		temp = check_otp_lenc(i);
		if (temp == 2) {
			otp_index = i;
			break;
		}
	}

	if (i==3) {
		// no valid wb OTP data
		printk("no valid lens OTP data\n ");
		return 1;
	}

	read_otp_lenc(otp_index, &current_otp);

	update_lenc(&current_otp);

	// success
	return 0;

}

/* OTP END */
static int ov8825_set_mode(struct ov8825_info *info, struct ov8825_mode *mode)
{
	int sensor_mode;
	int err;
	int val ;
	struct ov8825_reg reg_list[7];
    u8 pos1, pos2;

    err = ov8825_i2c_read_reg(NULL,0x3618, &pos1);
    err |= ov8825_i2c_read_reg(NULL,0x3619, &pos2);
    if(err) {
        return err;
    }
	#if OV8825_PRINT
	printk("%s: xres %u yres %u framelength %u coarsetime %u gain %u\n",
		__func__, mode->xres, mode->yres, mode->frame_length,
		mode->coarse_time, mode->gain);
	#endif

	if (mode->xres == 3264 && mode->yres == 2448)
		sensor_mode = OV8825_MODE_3264x2448;
	else if (mode->xres == 1920 && mode->yres == 1080)
		sensor_mode = OV8825_MODE_1920x1080;
	else if (mode->xres == 1632 && mode->yres == 1224)
		sensor_mode = OV8825_MODE_1632x1224;
	else {
		pr_err("%s: invalid resolution supplied to set mode %d %d\n",
		       __func__, mode->xres, mode->yres);
		return -EINVAL;
	}

	/* get a list of override regs for the asking frame length, */
	/* coarse integration time, and gain.                       */
	ov8825_get_frame_length_regs(reg_list, mode->frame_length);
	ov8825_get_coarse_time_regs(reg_list + 2, mode->coarse_time);
	ov8825_get_gain_reg(reg_list + 5, mode->gain);

    err = 0;
	err = ov8825_write_table(mode_table[sensor_mode],
	reg_list, 7);
	if (err)
		return err;

    err = ov8825_i2c_write_reg(NULL,0x3618, pos1);
    err |= ov8825_i2c_write_reg(NULL,0x3619, pos2);
    if(err) {
        return err;
    }
	ov8825_i2c_write_reg(NULL, 0x0100, 0x01); 
	/* otp */
	val = ov8825_cam_clibratiion_flag();
	//printk("8825 set mode val =%d\n",val);
	mdelay(5);
	if (val ==OV8825_OTP_WB_CAL_EN)    // only wb
	{
		update_otp_wb();
		printk("OV calibration: AWB ON, LSC OFF\n");
	}
	else if (val ==OV8825_OTP_LENS_CAL_EN)  // only lens
	{
		update_otp_lenc();
		printk("OV calibration: AWB OFF, LSC ON\n");
	}
	else if (val ==OV8825_OTP_WB_LENS_CAL_UN )
	{
		printk("OV calibration: AWB OFF, LSC OFF\n");
	}
	else  // for wb and lens
	{
		update_otp_wb();
		update_otp_lenc();
		printk("OV calibration: AWB ON, LSC ON\n");
	}

	/* otp end */
	msleep(20);
	info->mode = sensor_mode;
	return 0;
}

static int ov8825_set_frame_length(struct ov8825_info *info, u32 frame_length)
{
	struct ov8825_reg reg_list[2];
	int i = 0;
	int ret;
//pr_info("-- %s -- frame_length %u\n", __func__, frame_length);
	ov8825_get_frame_length_regs(reg_list, frame_length);

	for (i = 0; i < 2; i++)	{
		ret = ov8825_write_reg(reg_list[i].addr,
			reg_list[i].val);
		if (ret)
			return ret;
	}

	return 0;
}

static int ov8825_set_coarse_time(struct ov8825_info *info, u32 coarse_time)
{
	int ret;
    
	struct ov8825_reg reg_list[3];
	int i = 0;

//pr_info("-- %s -- coarse_time %u\n", __func__, coarse_time);
	ov8825_get_coarse_time_regs(reg_list, coarse_time);

	for (i = 0; i < 3; i++)	{
		ret = ov8825_write_reg(reg_list[i].addr,
			reg_list[i].val);
		if (ret)
			return ret;
	}
    	
	return 0;
}

static int ov8825_set_gain(struct ov8825_info *info, u16 gain)
{
	int i = 0;
	int ret;

	struct ov8825_reg reg_list[2];
	// printk("ov8825_set_gain gain=%x",gain);
	ov8825_get_gain_reg(reg_list, gain);
//pr_info("-- %s -- set gain %x\n", __func__, gain);

	for (i = 0; i < 2; i++)	{
		ret = ov8825_write_reg(reg_list[i].addr,
			reg_list[i].val);
		if (ret)
			return ret;
	}
	
	return ret;
}

static int ov8825_get_status(struct ov8825_info *info, u8 *status)
{
	int err;

	err = ov8825_read_reg(0x380e, status);
	*status = 0;
	return err;
}

static int ov8825_set_group_hold(struct ov8825_info *info, struct ov8825_ae *ae)
{
	int ret;
	int count = 0;
	bool groupHoldEnabled = false;
	#if OV8825_PRINT
    pr_info("%s %d\n", __func__, __LINE__);
	#endif

	if (ae->gain_enable)
		count++;
	if (ae->coarse_time_enable)
		count++;
	if (ae->frame_length_enable)
		count++;
	if (count >= 2)
		groupHoldEnabled = true;

	if (groupHoldEnabled) {
		ret = ov8825_write_reg(0x3208, 0x00);
		if (ret)
			return ret;
	}

	if (ae->gain_enable)
		ov8825_set_gain(info, ae->gain);
	if (ae->coarse_time_enable)
		ov8825_set_coarse_time(info, ae->coarse_time);
	if (ae->frame_length_enable)
		ov8825_set_frame_length(info, ae->frame_length);

	if (groupHoldEnabled) {
		ret = ov8825_write_reg(0x3208, 0x10);
		if (ret)
			return ret;


		ret = ov8825_write_reg(0x3208, 0xa0);
		if (ret)
			return ret;
	}
       
	return 0;
}

static long ov8825_ioctl(struct file *file,
			 unsigned int cmd, unsigned long arg)
{
	int err;
	struct ov8825_info *info = file->private_data;

	switch (cmd) {
	case OV8825_IOCTL_SET_MODE:
	{
		struct ov8825_mode mode;
		if (copy_from_user(&mode,
				   (const void __user *)arg,
				   sizeof(struct ov8825_mode))) {
			return -EFAULT;
		}

		return ov8825_set_mode(info, &mode);
	}
	case OV8825_IOCTL_SET_FRAME_LENGTH:
		return ov8825_set_frame_length(info, (u32)arg);
	case OV8825_IOCTL_SET_COARSE_TIME:
		return ov8825_set_coarse_time(info, (u32)arg);
	case OV8825_IOCTL_SET_GAIN:
		return ov8825_set_gain(info, (u16)arg);
	case OV8825_IOCTL_GET_STATUS:
	{
		u8 status;

		err = ov8825_get_status(info, &status);
		if (err)
			return err;
		if (copy_to_user((void __user *)arg, &status,
				 2)) {
			return -EFAULT;
		}
		return 0;
	}
	case OV8825_IOCTL_GET_SENSOR_ID:
	{
		if (FuseIDReadOnce == 0)
		{
			int err = 0;
			err |= ov8825_write_reg(OV8825_OTP_BANK_SELECT, OV8825_OTP_BANK_EN_BIT);
			err |= ov8825_write_reg(OV8825_OTP_READ_NWRITE, OV8825_OTP_READ_BIT);
			msleep(10);
			// read the 5-byte fuse id
			err |= ov8825_i2c_read_reg(NULL,OV8825_FUSEID_REG0, &FuseID[0]);
			err |= ov8825_i2c_read_reg(NULL,OV8825_FUSEID_REG1, &FuseID[1]);
			err |= ov8825_i2c_read_reg(NULL,OV8825_FUSEID_REG2, &FuseID[2]);
			err |= ov8825_i2c_read_reg(NULL,OV8825_FUSEID_REG3, &FuseID[3]);
			err |= ov8825_i2c_read_reg(NULL,OV8825_FUSEID_REG4, &FuseID[4]);

			if (err) {
				pr_err("%s GET_SENSOR_ID %d %d\n", __func__, __LINE__, err);
				return err;
			}
			//pr_info("ov8825 %s FuseID: %X %X %X %X %X\n", __func__,
			//	FuseID[0], FuseID[1], FuseID[2], FuseID[3], FuseID[4]);
			FuseIDReadOnce = 1;
		}
		if (copy_to_user((void __user *)arg, FuseID,
				 5)) {
			pr_info("[CAM] %s %d\n", __func__, __LINE__);
			return -EFAULT;
		}
		return 0;
	}
	case OV8825_IOCTL_SET_GROUP_HOLD:
	{
		struct ov8825_ae ae;
		if (copy_from_user(&ae,
				(const void __user *)arg,
				sizeof(struct ov8825_ae))) {
			pr_info("%s %d\n", __func__, __LINE__);
			return -EFAULT;
		}
		return ov8825_set_group_hold(info, &ae);
	}
	default:
		return -EINVAL;
	}
	return 0;
}

static int ov8825_open(struct inode *inode, struct file *file)
{
	u8 status;

	file->private_data = info;

	// msleep(100);
	ov8825_get_status(info, &status);
	return 0;
}

int ov8825_release(struct inode *inode, struct file *file)
{
	if (info->pdata && info->pdata->power_off)
		info->pdata->power_off();
	file->private_data = NULL;
	return 0;
}


static const struct file_operations ov8825_fileops = {
	.owner = THIS_MODULE,
	.open = ov8825_open,
	.unlocked_ioctl = ov8825_ioctl,
	.release = ov8825_release,
};

static struct miscdevice ov8825_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "ov8825",
	.fops = &ov8825_fileops,
};

static int ov8825_probe(struct platform_device *client)
{
	int err;

	pr_info("ov8825: probing sensor.\n");

	info = kzalloc(sizeof(struct ov8825_info), GFP_KERNEL);
	if (!info) {
		pr_err("ov8825: Unable to allocate memory!\n");
		return -ENOMEM;
	}

	err = misc_register(&ov8825_device);
	if (err) {
		pr_err("ov8825: Unable to register misc device!\n");
		kfree(info);
		return err;
	}
	create_cam_cal_proc_file();
	return 0;
}

static int ov8825_remove(struct platform_device *client)
{
	struct ov8825_info *info;

	pr_info("%s\n", __func__);
    info = platform_get_drvdata(client);
	misc_deregister(&ov8825_device);
	kfree(info);

	return 0;
}

static const struct platform_device_id ov8825_id[] = {
	{ "ov8825", 0 },
	{ },
};

MODULE_DEVICE_TABLE(platform, ov8825_id);

static struct platform_driver ov8825_driver = {
	.driver = {
		.name = "ov8825",
		.owner = THIS_MODULE,
	},
	.probe = ov8825_probe,
	.remove = ov8825_remove,
	.id_table = ov8825_id,
};

static int __init ov8825_init(void)
{
	pr_info("ov8825 sensor driver loading\n");
	return platform_driver_register(&ov8825_driver);
}

static void __exit ov8825_exit(void)
{
	pr_info("%s sensor driver exiting\n", __func__);
	FuseIDReadOnce = 0;
	platform_driver_unregister(&ov8825_driver);
}

module_init(ov8825_init);
module_exit(ov8825_exit);
MODULE_LICENSE("GPL v2");
